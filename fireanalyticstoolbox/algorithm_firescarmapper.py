"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from fire2a.raster import get_rlayer_data, get_rlayer_info
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterRasterDestination, QgsLayerTreeLayer, QgsProject, QgsRasterLayer, QgsProcessingException, QgsSingleBandPseudoColorRenderer, QgsGradientColorRamp, QgsMultiBandColorRenderer)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QColor
import torch
from .firescarmapping.model_u_net import model, device
from .firescarmapping.as_dataset import create_datasetAS
import numpy as np
from torch.utils.data import DataLoader
import os
from osgeo import gdal, gdal_array
import requests

class FireScarMapper(QgsProcessingAlgorithm):
    IN_BEFORE = "BeforeRasters"
    IN_AFTER = "AfterRasters"
    OUT_SCARS = "OutputScars"
    model_download_url = "https://fire2a-firescar-as-model.s3.amazonaws.com/ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model"
    model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_BEFORE,
                description=self.tr("Input rasters of non burned landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_AFTER,
                description=self.tr("Input rasters of burnt landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_SCARS,
                description=self.tr("Output mapped scars in a single raster"),
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        if not os.path.exists(self.model_path):
            feedback.pushInfo("Model not found. Initializing download...")
            self.download_model(feedback)

        before = self.parameterAsLayerList(parameters, self.IN_BEFORE, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in before]}\ntypes: {[ r.rasterType() for r in before]}")
        burnt = self.parameterAsLayerList(parameters, self.IN_AFTER, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in burnt]}\ntypes: {[ r.rasterType() for r in burnt]}")
        model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')

        output_path = self.parameterAsOutputLayer(parameters, self.OUT_SCARS, context)
        all_parameters = parameters['BeforeRasters'] + parameters['AfterRasters']
        
        if len(before) != len(burnt):
            raise QgsProcessingException("The number of before and burnt rasters must be the same")
        
        rasters = []
        for i, layer in enumerate(before + burnt):
            adict = {
                "type": "before" if i < len(before) else "burnt",
                "id": i,
                "qid": layer.id(),
                "name": layer.name()[8:],
                "data": get_rlayer_data(layer),
                "layer": layer,
                "path": layer.dataProvider().dataSourceUri(),
            }
            adict.update(get_rlayer_info(layer))
            rasters += [adict]

        before_files = []
        after_files = []
        before_files_data = []
        after_files_data = []

        #Order rasters
        for i in range(len(rasters)//2):
            before_files.append(rasters[i])
            before_files_data.append(before_files[i]['data'])
            for j in range(len(rasters)//2): #starts iterating from the second half
                if rasters[i]['name'] == rasters[j + (len(rasters)//2)]['name']:
                    after_files.append(rasters[j + (len(rasters)//2)])
                    after_files_data.append(after_files[i]['data'])

        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))

        np.random.seed(3)
        torch.manual_seed(3)    
        
        data_eval = create_datasetAS(before_files_data, after_files_data, mult=1)
        
        batch_size = 1 # 1 to create diagnostic images, any value otherwise
        all_dl = DataLoader(data_eval, batch_size=batch_size)#, shuffle=True)

        model.eval()

        for i, batch in enumerate(all_dl):
            x = batch['img'].float().to(device)
            output = model(x).cpu()

            # obtain binary prediction map
            pred = np.zeros(output.shape)
            pred[output >= 0] = 1

            generated_matrix = pred[0][0]
            
            if output_path:
                
                group_name = before_files[i]['name'].split("_")[0] + "_" + before_files[i]['name'].split("_")[1]
                root = QgsProject.instance().layerTreeRoot()
                group = root.findGroup(group_name)
                if not group:
                    group = root.addGroup(group_name)
                
                # Adjust the name of the output path to be unique for each firescar
                output_path_with_name= output_path.replace('OutputScars.tif', f"FireScar_{before_files[i]['name']}.tif")

                self.writeRaster(generated_matrix, output_path_with_name, before_files[i], feedback)
                self.addRasterLayer(output_path_with_name,f"FireScar_{before_files[i]['name']}", group, context)
                self.addRasterLayer(after_files[i]['path'],f"ImgPosF_{after_files[i]['name']}", group, context)
                self.addRasterLayer(before_files[i]['path'],f"ImgPreF_{before_files[i]['name']}", group, context)
        return {}

    def download_model(self, feedback):
        """Download the model from Amazon S3."""
        def save_response_content(response, destination):
            """Guardar el contenido descargado en el archivo de destino."""
            CHUNK_SIZE = 32768
            with open(destination, "wb") as f:
                for chunk in response.iter_content(CHUNK_SIZE):
                    if chunk:  # Filtra los "keep-alive" chunks vacÃ­os
                        f.write(chunk)

        session = requests.Session()
        response = session.get(self.model_download_url, stream=True)
        feedback.pushInfo(f"Downloading model to {self.model_path}")
        save_response_content(response, self.model_path)
        feedback.pushInfo(f"Model successfully downloaded and saved at {self.model_path}")

    def writeRaster(self, matrix, file_path, before_layer, feedback):

        # Get the dimensions of the raster before the fire
        width = before_layer["width"]
        height = before_layer["height"]

        # Create the output raster file
        driver = gdal.GetDriverByName('GTiff')
        raster = driver.Create(file_path, width, height, 1, gdal.GDT_Byte)

        if raster is None:
            raise QgsProcessingException("Failed to create raster file.")

        # Set the geotransformation and projection
        extent = before_layer["extent"]
        pixel_width = extent.width() / width
        pixel_height = extent.height() / height
        raster.SetGeoTransform((extent.xMinimum(), pixel_width, 0, extent.yMaximum(), 0, -pixel_height))
        raster.SetProjection(before_layer["crs"].toWkt())

        # Get the raster band
        band = raster.GetRasterBand(1)

        # Calculate the offset and size of the burn scar region to fit the raster
        start_row = 0
        start_col = 0
        matrix_height, matrix_width = matrix.shape

        if matrix_height > height:
            start_row = (matrix_height - height) // 2
            matrix_height = height
        if matrix_width > width:
            start_col = (matrix_width - width) // 2
            matrix_width = width

        # Crop the matrix to match the raster dimensions
        resized_matrix = matrix[start_row:start_row + matrix_height, start_col:start_col + matrix_width]

        # Write the matrix to the raster band
        try:
            gdal_array.BandWriteArray(band, resized_matrix, 0, 0)
        except ValueError as e:
            raise QgsProcessingException(f"Failed to write array to raster: {str(e)}")

        # Set the NoData value
        band.SetNoDataValue(0)
        
        # Ensure that the minimum and maximum values are updated
        band.ComputeStatistics(False)
        band.SetStatistics(0, 1, 0.5, 0.5)

        # Flush cache and close the raster
        band.FlushCache()
        raster.FlushCache()
        raster = None

        feedback.pushInfo(f"Raster written to {file_path}")

    def addRasterLayer(self, file_path, layer_name, group, context):
        """AÃ±adir la capa raster al grupo en el proyecto."""
        layer = QgsRasterLayer(file_path, layer_name, "gdal")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load raster layer from {file_path}")

        QgsProject.instance().addMapLayer(layer, False)
        
        # Insertar la nueva capa al final del grupo
        group.insertChildNode(len(group.children()), QgsLayerTreeLayer(layer))
        

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()