"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2024 by Diego Teran - Fire2a.com
        email                : FIX-ME
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from fire2a.raster import get_rlayer_data, get_rlayer_info
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterFile, QgsProject, QgsRasterLayer, QgsProcessingException)
from qgis.PyQt.QtCore import QCoreApplication

import torch
from .firescarmapping.model_u_net import model, device
from .firescarmapping.as_dataset import create_datasetAS
import numpy as np
from torch.utils.data import DataLoader
import rasterio
from rasterio.transform import from_origin


class FireScarMapper(QgsProcessingAlgorithm):
    IN_BEFORE = "BeforeRasters"
    IN_AFTER = "AfterRasters"
    OUT_SCARS = "OutputScars"
    IN_MODEL = "Trained Model"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_BEFORE,
                description=self.tr("Input rasters of non burned landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.IN_AFTER,
                description=self.tr("Input rasters of burnt landscape"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_MODEL,
                description=self.tr("Trained model file"),
                extension="model",
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_SCARS,
                description=self.tr("Output mapped scars in a single raster"),
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        before = self.parameterAsLayerList(parameters, self.IN_BEFORE, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in before]}\ntypes: {[ r.rasterType() for r in before]}")
        burnt = self.parameterAsLayerList(parameters, self.IN_AFTER, context)
        feedback.pushDebugInfo(f"Input rasters:\n names: {[ r.name() for r in burnt]}\ntypes: {[ r.rasterType() for r in burnt]}")
        model_path = self.parameterAsFile(parameters, self.IN_MODEL, context)
        output_path = self.parameterAsOutputLayer(parameters, self.OUT_SCARS, context)

        if len(before) != len(burnt):
            raise QgsProcessingException("The number of before and burnt rasters must be the same")
        rasters = []
        for i, layer in enumerate(before + burnt):
            adict = {
                "type": "before" if i < len(before) else "burnt",
                "id": i,
                "qid": layer.id(),
                "name": layer.name()[8:],
                "data": get_rlayer_data(layer),
                "layer": layer,
            }
            adict.update(get_rlayer_info(layer))
            rasters += [adict]
        #feedback.pushDebugInfo(f"{rasters=}, {len(rasters)=} {[r['data'].shape for r in rasters]}")

        before_files = []
        after_files = []
        before_files_data = []
        after_files_data = []

        #Order rasters
        for i in range(len(rasters)//2):
            before_files.append(rasters[i])
            before_files_data.append(before_files[i]['data'])
            for j in range(len(rasters)//2): #starts iterating from the second half
                if rasters[i]['name'] == rasters[j + (len(rasters)//2)]['name']:
                    after_files.append(rasters[j + (len(rasters)//2)])
                    after_files_data.append(after_files[i]['data'])

        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))

        np.random.seed(3)
        torch.manual_seed(3)    
        
        data_eval = create_datasetAS(before_files_data, after_files_data, mult=1)
        
        batch_size = 1 # 1 to create diagnostic images, any value otherwise
        all_dl = DataLoader(data_eval, batch_size=batch_size)#, shuffle=True)

        model.eval()

        for i, batch in enumerate(all_dl):
            x = batch['img'].float().to(device)
            output = model(x).cpu()

            # obtain binary prediction map
            pred = np.zeros(output.shape)
            pred[output >= 0] = 1

            generated_matrix = pred[0][0]
            
            if output_path:
                # Ajustar el nombre del archivo de salida para que sea único para cada cicatriz
                output_path_with_index = output_path[:-4] + f"_{i+1}.tif"

                self.writeRaster(generated_matrix, output_path_with_index, context)
                #it's (-1*i)-1 because it starts from the last
                self.addRasterLayer(output_path_with_index, before_files[(-1*i)-1]['name'], context)

        return {}

    def writeRaster(self, matrix, file_path, context):
        """
        Guarda una matriz como un archivo raster en formato TIF utilizando rasterio.

        :param matrix: Matriz de datos a guardar.
        :param file_path: Ruta del archivo TIF de salida.
        :param context: Contexto de procesamiento.
        """
        height, width = matrix.shape

        # Definir la transformación (resolución y origen)
        transform = from_origin(0, 0, 1, 1)  # Usar una resolución de 1x1 y el origen en (0, 0)

        # Definir los metadatos del archivo raster
        meta = {
            'driver': 'GTiff',
            'height': height,
            'width': width,
            'count': 1,  # Solo hay una banda en la matriz
            'dtype': matrix.dtype,
            'crs': 'EPSG:4326',  # Definir el sistema de referencia espacial (CRS)
            'transform': transform
        }

        # Guardar la matriz como un archivo TIF utilizando rasterio
        with rasterio.open(file_path, 'w', **meta) as dst:
            dst.write(matrix, 1)  # Escribir la matriz en la primera banda del archivo TIF


    def addRasterLayer(self, file_path, layer_name, context):
        """
        :param file_path: Ruta del archivo raster.
        :param context: Contexto de procesamiento.
        """
        # Cargar el archivo TIF como una capa raster en QGIS
        layer = QgsRasterLayer(file_path, layer_name, "gdal")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load raster layer from {file_path}")

        QgsProject.instance().addMapLayer(layer)

    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()
